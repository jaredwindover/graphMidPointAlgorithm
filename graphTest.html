<!DOCTYPE HTML>
<HTML>
<HEAD>
</HEAD>
<BODY>
<CANVAS width="800px" height="600px"></CANVAS>
<SCRIPT>
var currentIteration = 0;
var numPoints = 20;
var numEdges = 50;
var iterationCount = 40000;
var constantOfAttraction = 1;
var constantOfAttractionDivisor = 5;
var constantOfRepulsion = 10000;
var constantOfBarrierRepulsion = 100000;
var constantOfMidPoint2MidPointRepulsion = 10000;
var constantOfMidPoint2PointRepulsion = 10000;
var timeStep = 0.01;
var fastForward = 400;
var zeroPoint = {x: 0, y: 0};
var upPoint = {x: 0, y: 1};
var downPoint = {x: 0, y: -1};
var leftPoint = {x: -1, y: 0};
var rightPoint = {x: 1, y: 0};
var canvas;
var context;
var points;
var midPoints;
var inEdges;
var outEdges;
var forces;
var velocities;
function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min)) + min;
}
function initPoints(n) {
	var points = [];
	for (var i = 0; i < n; i++) {
		points[i] = {x: getRandomInt(0,canvas.width),y: getRandomInt(0,canvas.height)};
	}
	return points;
}
function addHalfEdge(edges, a, b) {
	if (edges[a] == undefined) {
		edges[a] = [b];
	} else {
		edges[a].push([b]);
	}
}
function addEdge(outEdges, inEdges, a, b) {
	addHalfEdge(outEdges, a, b);
	addHalfEdge(inEdges, b, a);
}
function initEdges(n,k) {
	var inEdges = {};
	var outEdges = {};
	var left;
	var right;
	for (var i = 0; i < n; i++) {
		left = getRandomInt(0, k);
		right = getRandomInt(0, k - 1);
		if (right >= left) {
			right += 1;
		}
		addEdge(outEdges, inEdges, left, right);
	}
	return {outEdges: outEdges,inEdges: inEdges};
}
function getMidPoint(point, otherPoint) {
	return pointDivScalar(pointSum(point, otherPoint), 2);
}
function getMidPoints(edges) {
	var midPoints = [];
	var otherPoints;
	for (var v in edges) {
		point = points[v];
		otherPoints = edges[v];
		for (var i = 0; i < otherPoints.length; i++) {
			otherPoint = points[otherPoints[i]];
			midPoints.push({p: getMidPoint(point, otherPoint), a: v, b: i});
		}
	}
	return midPoints;
}
function init() {
	canvas = document.querySelector("canvas");
	context = canvas.getContext("2d");
	points = initPoints(numPoints);
	velocities = points.map(function(p) {return zeroPoint;});
	forces = velocities;
	var edgesPair = initEdges(numEdges, numPoints);
	outEdges = edgesPair.outEdges;
	inEdges = edgesPair.inEdges;
	midPoints = getMidPoints(outEdges);
}
function drawCircle(context, radius, point) {
	context.beginPath();
	context.arc(point.x, point.y, radius, 0, 2*Math.PI);
	context.fill();
	context.stroke();
}
function drawLine(context, point, otherPoint) {
	context.beginPath();
	context.moveTo(point.x,point.y);
	context.lineTo(otherPoint.x,otherPoint.y);
	context.stroke();
}
function drawPoints(context, points) {
	for (var i = 0; i < points.length; i++) {
		var point = points[i];
		drawCircle(context, 20, point);
		//console.log(point.x + "," + point.y);
	}
}
function drawMidPoints(context, midPoints) {
	for (var i = 0; i < midPoints.length; i++) {
		var midPoint = midPoints[i];
		drawCircle(context, 10, midPoint.p);
	}
}
function drawEdges(context, edges) {
	for (var edge in edges ) {
		others = edges[edge];
		for (var otherEdgeIndex = 0; otherEdgeIndex < others.length; otherEdgeIndex ++ ) {
			//console.log("(" + edge + "," + otherEdge + ")");
			var otherEdge = others[otherEdgeIndex];
			edgePoint = points[edge];
			otherEdgePoint = points[otherEdge];
			drawLine(context, edgePoint, otherEdgePoint);
		}
	}
}
function clear() {
	context.clearRect(0,0, canvas.width, canvas.height);
}
function getPoint(v) {
	return points[v];
}
function squaredDistance(point, otherPoint) {
	return squaredMagnitude(pointDelta(point, otherPoint));
}
function squaredMagnitude(point) {
	return Math.pow(point.x, 2) + Math.pow(point.y, 2);
}
function pointDelta(point, otherPoint) {
	return {x : otherPoint.x - point.x, y: otherPoint.y - point.y};
}
function pointSum(point, otherPoint) {
	return {x: otherPoint.x + point.x, y: otherPoint.y + point.y};
}
function pointDivScalar(point, scalar) {
	return {x : point.x / scalar, y: point.y / scalar};
}
function pointTimesScalar(point, scalar) {
	return {x : point.x * scalar, y: point.y * scalar};
}
function update() {
	var point;
	var ies;
	var oes;
	var ips;
	var ops;
	var otherPoints;
	var d2;
	var d;
	var dir;
	var newForce;
	// forces per point
	for (var i = 0; i < points.length; i++) {
		point = points[i];
		ies = inEdges[i];
		oes = outEdges[i];
		ips = ies == undefined ? [] : ies.map(getPoint);
		ops = oes == undefined ? [] : oes.map(getPoint);
		otherPoints = ips.concat(ops);
		forces[i] = zeroPoint;
		// point on point attractive forces (edges)
		for (var j = 0; j < otherPoints.length; j++) {
			otherPoint = otherPoints[j];
			d2 = squaredDistance(point, otherPoint);
			d = Math.sqrt(d2);
			if (d != 0) {
				dir = pointDivScalar(pointDelta(point, otherPoint), d);
				forces[i] = pointSum(forces[i], pointTimesScalar(dir, constantOfAttraction*Math.log(d/constantOfAttractionDivisor)));
			}
		}
		// point on point repulsive forces
		for (var j = 0; j < points.length; j++) {
			if (i != j) {
				otherPoint = points[j];
				d2 = squaredDistance(point, otherPoint);
				if (d2 != 0) {
					d = Math.sqrt(d2);
					dir = pointDivScalar(pointDelta(point, otherPoint), d);
					var newForce = pointTimesScalar(dir, -constantOfRepulsion/d2);
					forces[i] = pointSum(forces[i], newForce);
				}
			}
		}
		// barrier repulsive forces
		dir = downPoint;
		d = point.y;
		d2 = Math.pow(d,2);
		if (d2 != 0) {
			newForce = pointTimesScalar(dir, -constantOfBarrierRepulsion/d2);
			forces[i] = pointSum(forces[i], newForce);
		}
		
		dir = upPoint;
		d = canvas.height - point.y;
		d2 = Math.pow(d,2);
		if (d2 != 0) {
			newForce = pointTimesScalar(dir, -constantOfBarrierRepulsion/d2);
			forces[i] = pointSum(forces[i], newForce);
		}
		
		dir = leftPoint;
		d = point.x;
		d2 = Math.pow(d,2);
		if (d2 != 0) {
			newForce = pointTimesScalar(dir, -constantOfBarrierRepulsion/d2);
			forces[i] = pointSum(forces[i], newForce);
		}
		
		dir = rightPoint;
		d = canvas.width - point.x;
		d2 = Math.pow(d,2);
		if (d2 != 0) {
			newForce = pointTimesScalar(dir, -constantOfBarrierRepulsion/d2);
			forces[i] = pointSum(forces[i], newForce);
		}
	}
	// midPoint forces
	for (var i = 0; i < midPoints.length; i++) {
		midPoint = midPoints[i];
		mp = midPoint.p;
		// midPoint on midPoint repulsive forces
		for (var j = 0; j < midPoints.length; j++) {
			if (i != j) {
				otherMidPoint = midPoints[j];
				omp = otherMidPoint.p;
				d2 = squaredDistance(mp, omp);
				if (d2 != 0) {
					d = Math.sqrt(d2);
					dir = pointDivScalar(pointDelta(mp, omp), d);
					var newForce = pointTimesScalar(dir, -constantOfMidPoint2MidPointRepulsion/(2*d2));
					forces[midPoint.a] = pointSum(forces[midPoint.a], newForce);
					forces[midPoint.b] = pointSum(forces[midPoint.b], newForce);
				}
			}
		}
		// point on midPoint repulsive forces
		for (var j = 0; j < points.length; j++) {
			otherPoint = points[j];
			d2 = squaredDistance(mp, otherPoint);
			if (d2 != 0) {
				d = Math.sqrt(d2);
				dir = pointDivScalar(pointDelta(mp, otherPoint), d);
				var newForce = pointTimesScalar(dir, -constantOfMidPoint2PointRepulsion/(2*d2));
				forces[midPoint.a] = pointSum(forces[midPoint.a], newForce);
				forces[midPoint.b] = pointSum(forces[midPoint.b], newForce);
			}			
		}
	}
	
	// update velocities with forces
	for (var i = 0; i < points.length; i++) {
		velocities[i] = pointSum(velocities[i], forces[i]);
	}
	
	// update positions with velocities
	for (var i = 0; i < points.length; i++) {
		displacement = pointTimesScalar(velocities[i], timeStep*(1 - (currentIteration/iterationCount)));
		//console.log(displacement.x + "," + displacement.y);
		points[i] = pointSum(points[i], displacement);
		if (points[i].x < 0) {
			points[i].x = 0;
			velocities[i].x = 0;
		} 
		//points[i].x = Math.max(0, points[i].x);
		if (points[i].x > canvas.width) {
			points[i].x = canvas.width;
			velocities[i].x = 0;
		}
		//points[i].x = Math.min(canvas.width, points[i].x);
		if (points[i].y < 0) {
			points[i].y = 0;
			velocities[i].y = 0;
		} 
		//points[i].y = Math.max(0, points[i].y);
		if (points[i].y > canvas.height) {
			points[i].y = canvas.height;
			velocities[i].y = 0;
		} 
		//points[i].y = Math.min(canvas.height, points[i].y);
	}
	
	// update midPoint positions
	midPoints = getMidPoints(outEdges);
}
function draw() {
	context.fillStyle = "red";
	drawPoints(context, points);
	drawEdges(context, outEdges);
	context.fillStyle = "blue";
	drawMidPoints(context, midPoints);
}
function iterate(n) {
	if (n >= 0) {
		iterationCount++;
		update();
		//iterate(n - 1);
		clear();
		draw();
		setTimeout(function() {iterate(n - 1)}, 1000*timeStep/fastForward);
	}
}
function main() {
	init();
	draw();
	iterate(iterationCount);
	draw();
}
main();
</SCRIPT>
</BODY>
</HTML>